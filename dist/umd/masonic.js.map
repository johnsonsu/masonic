{"version":3,"file":"masonic.js","sources":["../../src/interval-tree.ts","../../node_modules/.pnpm/@react-hook+event@1.2.3_react@17.0.2/node_modules/@react-hook/event/src/index.tsx","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../node_modules/.pnpm/@react-hook+throttle@2.2.0_react@17.0.2/node_modules/@react-hook/throttle/src/index.tsx","../../src/use-scroller.ts","../../node_modules/.pnpm/@essentials+request-timeout@1.3.0/node_modules/@essentials/request-timeout/src/index.ts","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../src/use-positioner.ts","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/scheduler.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/process.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObservation.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/element.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserver.js","../../src/use-resize-observer.ts","../../src/use-scroll-to-index.ts","../../src/masonry.tsx","../../node_modules/.pnpm/@react-hook+window-size@3.0.7_react@17.0.2/node_modules/@react-hook/window-size/src/index.tsx","../../node_modules/.pnpm/@react-hook+debounce@3.0.0_react@17.0.2/node_modules/@react-hook/debounce/src/index.tsx","../../node_modules/.pnpm/@react-hook+latest@1.0.3_react@17.0.2/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/.pnpm/@react-hook+passive-layout-effect@1.2.1_react@17.0.2/node_modules/@react-hook/passive-layout-effect/src/index.tsx","../../node_modules/.pnpm/@essentials+memoize-one@1.1.0/node_modules/@essentials/memoize-one/src/index.ts","../../node_modules/.pnpm/@essentials+one-key-map@1.2.0/node_modules/@essentials/one-key-map/src/index.ts","../../node_modules/.pnpm/trie-memoize@1.2.0/node_modules/trie-memoize/src/index.ts","../../src/elements-cache.ts","../../node_modules/.pnpm/@essentials+raf@1.2.0/node_modules/@essentials/raf/src/index.ts","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","../../node_modules/.pnpm/@react-hook+window-scroll@1.3.0_react@17.0.2/node_modules/@react-hook/window-scroll/src/index.tsx","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/freeze.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/utils/global.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","../../node_modules/.pnpm/@juggle+resize-observer@3.3.1/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js","../../node_modules/.pnpm/raf-schd@4.0.3/node_modules/raf-schd/dist/raf-schd.esm.js","../../src/use-infinite-loader.ts","../../src/list.tsx"],"sourcesContent":["type Color = 0 | 1 | 2;\nconst RED = 0;\nconst BLACK = 1;\nconst NIL = 2;\n\nconst DELETE = 0;\nconst KEEP = 1;\n\ntype ListNode = {\n  index: number;\n  high: number;\n  next: ListNode | null;\n};\n\ninterface TreeNode {\n  max: number;\n  low: number;\n  high: number;\n  // color\n  C: Color;\n  // P\n  P: TreeNode;\n  // right\n  R: TreeNode;\n  // left\n  L: TreeNode;\n  list: ListNode;\n}\n\ninterface Tree {\n  root: TreeNode;\n  size: number;\n}\n\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\n  let node: ListNode | null = treeNode.list;\n  let prevNode: ListNode | undefined;\n\n  while (node) {\n    if (node.index === index) return false;\n    if (high > node.high) break;\n    prevNode = node;\n    node = node.next;\n  }\n\n  if (!prevNode) treeNode.list = { index, high, next: node };\n  if (prevNode) prevNode.next = { index, high, next: prevNode.next };\n\n  return true;\n}\n\nfunction removeInterval(treeNode: TreeNode, index: number) {\n  let node: ListNode | null = treeNode.list;\n  if (node.index === index) {\n    if (node.next === null) return DELETE;\n    treeNode.list = node.next;\n    return KEEP;\n  }\n\n  let prevNode: ListNode | undefined = node;\n  node = node.next;\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next;\n      return KEEP;\n    }\n    prevNode = node;\n    node = node.next;\n  }\n}\n\nconst NULL_NODE: TreeNode = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-expect-error\n  P: undefined,\n  // @ts-expect-error\n  R: undefined,\n  // @ts-expect-error\n  L: undefined,\n  // @ts-expect-error\n  list: undefined,\n};\n\nNULL_NODE.P = NULL_NODE;\nNULL_NODE.L = NULL_NODE;\nNULL_NODE.R = NULL_NODE;\n\nfunction updateMax(node: TreeNode) {\n  const max = node.high;\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max;\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max);\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max);\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max);\n}\n\nfunction updateMaxUp(node: TreeNode) {\n  let x = node;\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P);\n    x = x.P;\n  }\n}\n\nfunction rotateLeft(tree: Tree, x: TreeNode) {\n  if (x.R === NULL_NODE) return;\n  const y = x.R;\n  x.R = y.L;\n  if (y.L !== NULL_NODE) y.L.P = x;\n  y.P = x.P;\n\n  if (x.P === NULL_NODE) tree.root = y;\n  else {\n    if (x === x.P.L) x.P.L = y;\n    else x.P.R = y;\n  }\n\n  y.L = x;\n  x.P = y;\n\n  updateMax(x);\n  updateMax(y);\n}\n\nfunction rotateRight(tree: Tree, x: TreeNode) {\n  if (x.L === NULL_NODE) return;\n  const y = x.L;\n  x.L = y.R;\n  if (y.R !== NULL_NODE) y.R.P = x;\n  y.P = x.P;\n\n  if (x.P === NULL_NODE) tree.root = y;\n  else {\n    if (x === x.P.R) x.P.R = y;\n    else x.P.L = y;\n  }\n\n  y.R = x;\n  x.P = y;\n\n  updateMax(x);\n  updateMax(y);\n}\n\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\n  if (x.P === NULL_NODE) tree.root = y;\n  else if (x === x.P.L) x.P.L = y;\n  else x.P.R = y;\n  y.P = x.P;\n}\n\nfunction fixRemove(tree: Tree, x: TreeNode) {\n  let w;\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateLeft(tree, x.P);\n        w = x.P.R;\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK;\n          w.C = RED;\n          rotateRight(tree, w);\n          w = x.P.R;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.R.C = BLACK;\n        rotateLeft(tree, x.P);\n        x = tree.root;\n      }\n    } else {\n      w = x.P.L;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateRight(tree, x.P);\n        w = x.P.L;\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK;\n          w.C = RED;\n          rotateLeft(tree, w);\n          w = x.P.L;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.L.C = BLACK;\n        rotateRight(tree, x.P);\n        x = tree.root;\n      }\n    }\n  }\n\n  x.C = BLACK;\n}\n\nfunction minimumTree(x: TreeNode) {\n  while (x.L !== NULL_NODE) x = x.L;\n  return x;\n}\n\nfunction fixInsert(tree: Tree, z: TreeNode) {\n  let y: TreeNode;\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.R) {\n          z = z.P;\n          rotateLeft(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateRight(tree, z.P.P);\n      }\n    } else {\n      y = z.P.P.L;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.L) {\n          z = z.P;\n          rotateRight(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateLeft(tree, z.P.P);\n      }\n    }\n  }\n  tree.root.C = BLACK;\n}\n\nexport interface IIntervalTree {\n  insert(low: number, high: number, index: number): void;\n  remove(index: number): void;\n  search(\n    low: number,\n    high: number,\n    callback: (index: number, low: number) => any\n  ): void;\n  size: number;\n}\n\nexport function createIntervalTree(): IIntervalTree {\n  const tree = {\n    root: NULL_NODE,\n    size: 0,\n  };\n  // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n  const indexMap: Record<number, TreeNode> = {};\n\n  return {\n    insert(low, high, index) {\n      let x: TreeNode = tree.root;\n      let y: TreeNode = NULL_NODE;\n\n      while (x !== NULL_NODE) {\n        y = x;\n        if (low === y.low) break;\n        if (low < x.low) x = x.L;\n        else x = x.R;\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return;\n        y.high = Math.max(y.high, high);\n        updateMax(y);\n        updateMaxUp(y);\n        indexMap[index] = y;\n        tree.size++;\n        return;\n      }\n\n      const z: TreeNode = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: { index, high, next: null },\n      };\n\n      if (y === NULL_NODE) {\n        tree.root = z;\n      } else {\n        if (z.low < y.low) y.L = z;\n        else y.R = z;\n        updateMaxUp(z);\n      }\n\n      fixInsert(tree, z);\n      indexMap[index] = z;\n      tree.size++;\n    },\n\n    remove(index) {\n      const z = indexMap[index];\n      if (z === void 0) return;\n      delete indexMap[index];\n\n      const intervalResult = removeInterval(z, index);\n      if (intervalResult === void 0) return;\n      if (intervalResult === KEEP) {\n        z.high = z.list.high;\n        updateMax(z);\n        updateMaxUp(z);\n        tree.size--;\n        return;\n      }\n\n      let y = z;\n      let originalYColor = y.C;\n      let x: TreeNode;\n\n      if (z.L === NULL_NODE) {\n        x = z.R;\n        replaceNode(tree, z, z.R);\n      } else if (z.R === NULL_NODE) {\n        x = z.L;\n        replaceNode(tree, z, z.L);\n      } else {\n        y = minimumTree(z.R);\n        originalYColor = y.C;\n        x = y.R;\n\n        if (y.P === z) {\n          x.P = y;\n        } else {\n          replaceNode(tree, y, y.R);\n          y.R = z.R;\n          y.R.P = y;\n        }\n\n        replaceNode(tree, z, y);\n        y.L = z.L;\n        y.L.P = y;\n        y.C = z.C;\n      }\n\n      updateMax(x);\n      updateMaxUp(x);\n\n      if (originalYColor === BLACK) fixRemove(tree, x);\n      tree.size--;\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root];\n      while (stack.length !== 0) {\n        const node = stack.pop() as TreeNode;\n        if (node === NULL_NODE || low > node.max) continue;\n        if (node.L !== NULL_NODE) stack.push(node.L);\n        if (node.R !== NULL_NODE) stack.push(node.R);\n        if (node.low <= high && node.high >= low) {\n          let curr: ListNode | null = node.list;\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low);\n            curr = curr.next;\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size;\n    },\n  };\n}\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(target: any, type: any, listener: any, cleanup: any): void {\n  const storedListener = React.useRef(listener)\n  const storedCleanup = React.useRef(cleanup)\n\n  useLayoutEffect(() => {\n    storedListener.current = listener\n    storedCleanup.current = cleanup\n  })\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    let didUnsubscribe = 0\n    function listener(this: any, ...args: any[]) {\n      if (didUnsubscribe) return\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      didUnsubscribe = 1\n      targetEl.removeEventListener(type, listener)\n      cleanup && cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from \"react\";\n\nexport function useForceUpdate() {\n  const setState = React.useState(emptyObj)[1];\n  return React.useRef(() => setState({})).current;\n}\n\nconst emptyObj = {};\n","import memoizeOne from \"@essentials/memoize-one\";\nimport OneKeyMap from \"@essentials/one-key-map\";\nimport useLatest from \"@react-hook/latest\";\nimport * as React from \"react\";\nimport trieMemoize from \"trie-memoize\";\nimport { elementsCache } from \"./elements-cache\";\nimport { useForceUpdate } from \"./use-force-update\";\nimport type { Positioner } from \"./use-positioner\";\n\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options - Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n * @param options.positioner\n * @param options.resizeObserver\n * @param options.items\n * @param options.as\n * @param options.id\n * @param options.className\n * @param options.style\n * @param options.role\n * @param options.tabIndex\n * @param options.containerRef\n * @param options.itemAs\n * @param options.itemStyle\n * @param options.itemHeightEstimate\n * @param options.itemKey\n * @param options.overscanBy\n * @param options.scrollTop\n * @param options.isScrolling\n * @param options.height\n * @param options.render\n * @param options.onRender\n */\nexport function useMasonry<Item>({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = \"div\",\n  id,\n  className,\n  style,\n  role = \"grid\",\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = \"div\",\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender,\n}: UseMasonryOptions<Item>) {\n  let startIndex = 0;\n  let stopIndex: number | undefined;\n  const forceUpdate = useForceUpdate();\n  const setItemRef = getRefSetter(positioner, resizeObserver);\n  const itemCount = items.length;\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn,\n  } = positioner;\n  const measuredCount = size();\n  const shortestColumnSize = shortestColumn();\n  const children: React.ReactElement[] = [];\n  const itemRole =\n    role === \"list\" ? \"listitem\" : role === \"grid\" ? \"gridcell\" : undefined;\n  const storedOnRender = useLatest(onRender);\n\n  overscanBy = height * overscanBy;\n  const rangeEnd = scrollTop + overscanBy;\n  const needsFreshBatch =\n    shortestColumnSize < rangeEnd && measuredCount < itemCount;\n\n  range(\n    // We overscan in both directions because users scroll both ways,\n    // though one must admit scrolling down is more common and thus\n    // we only overscan by half the downward overscan amount\n    Math.max(0, scrollTop - overscanBy / 2),\n    rangeEnd,\n    (index, left, top) => {\n      const data = items[index];\n      const key = itemKey(data, index);\n      const phaseTwoStyle: React.CSSProperties = {\n        top,\n        left,\n        width: columnWidth,\n        writingMode: \"horizontal-tb\",\n        position: \"absolute\",\n      };\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== \"undefined\" &&\n        process.env.NODE_ENV !== \"production\"\n      ) {\n        throwWithoutData(data, index);\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === \"object\" && itemStyle !== null\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\n              : phaseTwoStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      );\n\n      if (stopIndex === void 0) {\n        startIndex = index;\n        stopIndex = index;\n      } else {\n        startIndex = Math.min(startIndex, index);\n        stopIndex = Math.max(stopIndex, index);\n      }\n    }\n  );\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(\n      itemCount - measuredCount,\n      Math.ceil(\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\n          columnCount\n      )\n    );\n\n    let index = measuredCount;\n    const phaseOneStyle = getCachedSize(columnWidth);\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index];\n      const key = itemKey(data, index);\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== \"undefined\" &&\n        process.env.NODE_ENV !== \"production\"\n      ) {\n        throwWithoutData(data, index);\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === \"object\"\n              ? Object.assign({}, phaseOneStyle, itemStyle)\n              : phaseOneStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      );\n    }\n  }\n\n  // Calls the onRender callback if the rendered indices changed\n  React.useEffect(() => {\n    if (typeof storedOnRender.current === \"function\" && stopIndex !== void 0)\n      storedOnRender.current(startIndex, stopIndex, items);\n\n    didEverMount = \"1\";\n  }, [startIndex, stopIndex, items, storedOnRender]);\n  // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n  React.useEffect(() => {\n    if (needsFreshBatch) forceUpdate();\n    // eslint-disable-next-line\n  }, [needsFreshBatch]);\n\n  // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n  const containerStyle = getContainerStyle(\n    isScrolling,\n    estimateHeight(itemCount, itemHeightEstimate)\n  );\n\n  return (\n    <ContainerComponent\n      ref={containerRef}\n      key={didEverMount}\n      id={id}\n      role={role}\n      className={className}\n      tabIndex={tabIndex}\n      style={\n        typeof style === \"object\"\n          ? assignUserStyle(containerStyle, style)\n          : containerStyle\n      }\n      children={children}\n    />\n  );\n}\n\n/* istanbul ignore next */\nfunction throwWithoutData(data: any, index: number) {\n  if (!data) {\n    throw new Error(\n      `No data was found at index: ${index}\\n\\n` +\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\n        `mutating the underlying \"items\".\\n\\n` +\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\n        `an example that gets around this limitations. For advanced implementations, see ` +\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\n        `https://github.com/jaredLunde/masonic/issues/12`\n    );\n  }\n}\n\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\nlet didEverMount = \"0\";\n\nexport interface UseMasonryOptions<Item> {\n  /**\n   * An array containing the data used by the grid items.\n   */\n  items: Item[];\n  /**\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\n   * the `createPositioner` utility.\n   */\n  positioner: Positioner;\n  /**\n   * A resize observer that tracks mutations to the grid cells and forces the\n   * Masonry grid to recalculate its layout if any cells affect column heights\n   * change. Check out the `useResizeObserver()` hook.\n   */\n  resizeObserver?: {\n    observe: ResizeObserver[\"observe\"];\n    disconnect: ResizeObserver[\"observe\"];\n    unobserve: ResizeObserver[\"unobserve\"];\n  };\n  /**\n   * This is the type of element the grid container will be rendered as.\n   *\n   * @default \"div\"`\n   */\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>;\n  /**\n   * Optionally gives the grid container an `id` prop.\n   */\n  id?: string;\n  /**\n   * Optionally gives the grid container a `className` prop.\n   */\n  className?: string;\n  /**\n   * Adds extra `style` attributes to the container in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  style?: React.CSSProperties;\n  /**\n   * Optionally swap out the accessibility `role` prop of the container and its items.\n   *\n   * @default \"grid\"\n   */\n  role?: \"grid\" | \"list\";\n  /**\n   * Change the `tabIndex` of the grid container.\n   *\n   * @default 0\n   */\n  tabIndex?: number;\n  /**\n   * Forwards a React ref to the grid container.\n   */\n  containerRef?:\n    | ((element: HTMLElement) => void)\n    | React.MutableRefObject<HTMLElement | null>;\n  /**\n   * This is the type of element the grid items will be rendered as.\n   *\n   * @default \"div\"\n   */\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>;\n  /**\n   * Adds extra `style` attributes to the grid items in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  itemStyle?: React.CSSProperties;\n  /**\n   * This value is used for estimating the initial height of the masonry grid. It is important for\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\n   *\n   * @default 300\n   */\n  itemHeightEstimate?: number;\n  /**\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\n   * ID here if there is one, e.g. `data => data.id`\n   *\n   * @default (data, index) => index`\n   */\n  itemKey?: (data: Item, index: number) => string | number;\n  /**\n   * This number is used for determining the number of grid cells outside of the visible window to render.\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\n   * linear relationship.\n   *\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\nlue may create too much work for React to handle, so it's best that you tune this\n   * value accordingly.\n   *\n   * @default 2\n   */\n  overscanBy?: number;\n\n  /**\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\n   * here.\n   */\n  height: number;\n  /**\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\n   * rendering the grid relative to the browser `window`.\n   */\n  scrollTop: number;\n  /**\n   * This property is used for determining whether or not the grid container should add styles that\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\n   * you're rendering the grid relative to the browser `window`.\n   *\n   * @default false\n   */\n  isScrolling?: boolean;\n  /**\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\n   * `index`, `width`, and `data`. See RenderComponentProps.\n   */\n  render: React.ComponentType<RenderComponentProps<Item>>;\n  /**\n   * This callback is invoked any time the items currently being rendered by the grid change.\n   */\n  onRender?: (startIndex: number, stopIndex: number, items: Item[]) => void;\n}\n\nexport interface RenderComponentProps<Item> {\n  /**\n   * The index of the cell in the `items` prop array.\n   */\n  index: number;\n  /**\n   * The rendered width of the cell's column.\n   */\n  width: number;\n  /**\n   * The data at `items[index]` of your `items` prop array.\n   */\n  data: Item;\n}\n\n//\n// Render-phase utilities\n\n// ~5.5x faster than createElement without the memo\nconst createRenderElement = trieMemoize(\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\n  (RenderComponent, index, data, columnWidth) => (\n    <RenderComponent index={index} data={data} width={columnWidth} />\n  )\n);\n\nconst getContainerStyle = memoizeOne(\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\n    position: \"relative\",\n    width: \"100%\",\n    maxWidth: \"100%\",\n    height: Math.ceil(estimateHeight),\n    maxHeight: Math.ceil(estimateHeight),\n    willChange: isScrolling ? \"contents\" : void 0,\n    pointerEvents: isScrolling ? \"none\" : void 0,\n  })\n);\n\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\n  args[0] === pargs[0] && args[1] === pargs[1];\n\nconst assignUserStyle = memoizeOne(\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\n  // @ts-expect-error\n  cmp2\n);\n\nfunction defaultGetItemKey<Item>(_: Item, i: number) {\n  return i;\n}\n\n// the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\nconst getCachedSize = memoizeOne(\n  (width: number): React.CSSProperties => ({\n    width,\n    zIndex: -1000,\n    visibility: \"hidden\",\n    position: \"absolute\",\n    writingMode: \"horizontal-tb\",\n  }),\n  (args, pargs) => args[0] === pargs[0]\n);\n\nconst getRefSetter = memoizeOne(\n  (\n      positioner: Positioner,\n      resizeObserver?: UseMasonryOptions<any>[\"resizeObserver\"]\n    ) =>\n    (index: number) =>\n    (el: HTMLElement | null): void => {\n      if (el === null) return;\n      if (resizeObserver) {\n        resizeObserver.observe(el);\n        elementsCache.set(el, index);\n      }\n      if (positioner.get(index) === void 0)\n        positioner.set(index, el.offsetHeight);\n    },\n  // @ts-expect-error\n  cmp2\n);\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nconst perf = typeof performance !== 'undefined' ? performance : Date\nconst now = () => perf.now()\n\nexport function useThrottleCallback<CallbackArguments extends any[]>(\n  callback: (...args: CallbackArguments) => void,\n  fps = 30,\n  leading = false\n): (...args: CallbackArguments) => void {\n  const storedCallback = useLatest(callback)\n  const ms = 1000 / fps\n  const prev = React.useRef(0)\n  const trailingTimeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const clearTrailing = () =>\n    trailingTimeout.current && clearTimeout(trailingTimeout.current)\n  const deps = [fps, leading, storedCallback]\n\n  // Reset any time the deps change\n  React.useEffect(\n    () => () => {\n      prev.current = 0\n      clearTrailing()\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const rightNow = now()\n    const call = () => {\n      prev.current = rightNow\n      clearTrailing()\n      storedCallback.current.apply(null, args as any)\n    }\n    const current = prev.current\n    // leading\n    if (leading && current === 0) return call()\n    // body\n    if (rightNow - current > ms) {\n      if (current > 0) return call()\n      prev.current = rightNow\n    }\n    // trailing\n    clearTrailing()\n    trailingTimeout.current = setTimeout(() => {\n      call()\n      prev.current = 0\n    }, ms)\n  }, deps)\n}\n\nexport function useThrottle<State>(\n  initialState: State | (() => State),\n  fps?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] {\n  const state = React.useState<State>(initialState)\n  return [state[0], useThrottleCallback(state[1], fps, leading)]\n}\n","import {\n  clearRequestTimeout,\n  requestTimeout,\n} from \"@essentials/request-timeout\";\nimport useScrollPosition from \"@react-hook/window-scroll\";\nimport * as React from \"react\";\n\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset - The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps - This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\nexport function useScroller(\n  offset = 0,\n  fps = 12\n): { scrollTop: number; isScrolling: boolean } {\n  const scrollTop = useScrollPosition(fps);\n  const [isScrolling, setIsScrolling] = React.useState(false);\n  const didMount = React.useRef(0);\n\n  React.useEffect(() => {\n    if (didMount.current === 1) setIsScrolling(true);\n    let didUnsubscribe = false;\n    const to = requestTimeout(() => {\n      if (didUnsubscribe) return;\n      // This is here to prevent premature bail outs while maintaining high resolution\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n      setIsScrolling(false);\n    }, 40 + 1000 / fps);\n    didMount.current = 1;\n    return () => {\n      didUnsubscribe = true;\n      clearRequestTimeout(to);\n    };\n  }, [fps, scrollTop]);\n\n  return { scrollTop: Math.max(0, scrollTop - offset), isScrolling };\n}\n","/**\n * Copyright 2011, Joe Lambert.\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n **/\nimport {raf, caf, now} from '@essentials/raf'\n\nexport interface RequestTimeoutHandle {\n  v?: number\n}\n\nexport const clearRequestTimeout = (handle: RequestTimeoutHandle): void => {\n  caf(handle.v || -1)\n}\n\nexport const requestTimeout = (\n  fn: (...args: any[]) => void,\n  ms: number\n): RequestTimeoutHandle => {\n  const start = now(),\n    handle: RequestTimeoutHandle = {}\n\n  const loop = () => {\n    now() - start >= ms ? fn.call(null) : (handle.v = raf(loop))\n  }\n\n  handle.v = raf(loop)\n  return handle\n}\n\nexport default requestTimeout\n","import { useMasonry } from \"./use-masonry\";\nimport type { UseMasonryOptions } from \"./use-masonry\";\nimport { useScroller } from \"./use-scroller\";\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n *\n * @param props\n */\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const { scrollTop, isScrolling } = useScroller(props.offset, props.scrollFps);\n  // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n  return useMasonry<Item>({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render,\n  });\n}\n\nexport interface MasonryScrollerProps<Item>\n  extends Omit<UseMasonryOptions<Item>, \"scrollTop\" | \"isScrolling\"> {\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   *\n   * @default 12\n   */\n  scrollFps?: number;\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the browser `document.documentElement`.\n   *\n   * @default 0\n   */\n  offset?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  MasonryScroller.displayName = \"MasonryScroller\";\n}\n","import useLayoutEffect from \"@react-hook/passive-layout-effect\";\nimport * as React from \"react\";\n\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef - A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps - You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\nexport function useContainerPosition(\n  elementRef: React.MutableRefObject<HTMLElement | null>,\n  deps: React.DependencyList = emptyArr\n): ContainerPosition {\n  const [containerPosition, setContainerPosition] =\n    React.useState<ContainerPosition>({ offset: 0, width: 0 });\n\n  useLayoutEffect(() => {\n    const { current } = elementRef;\n    if (current !== null) {\n      let offset = 0;\n      let el = current;\n\n      do {\n        offset += el.offsetTop || 0;\n        el = el.offsetParent as HTMLElement;\n      } while (el);\n\n      if (\n        offset !== containerPosition.offset ||\n        current.offsetWidth !== containerPosition.width\n      ) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth,\n        });\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  return containerPosition;\n}\n\nexport interface ContainerPosition {\n  /**\n   * The distance in pixels between the top of the element in `elementRef` and the top of\n   * the `document.documentElement`.\n   */\n  offset: number;\n  /**\n   * The `offsetWidth` of the element in `elementRef`.\n   */\n  width: number;\n}\n\nconst emptyArr: [] = [];\n","import * as React from \"react\";\nimport { createIntervalTree } from \"./interval-tree\";\n\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options - Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param options.columnWidth\n * @param options.width\n * @param deps - This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n * @param options.columnGutter\n * @param options.rowGutter\n * @param options.columnCount\n */\nexport function usePositioner(\n  {\n    width,\n    columnWidth = 200,\n    columnGutter = 0,\n    rowGutter,\n    columnCount,\n  }: UsePositionerOptions,\n  deps: React.DependencyList = emptyArr\n): Positioner {\n  const initPositioner = (): Positioner => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(\n      width,\n      columnWidth,\n      columnGutter,\n      columnCount\n    );\n    return createPositioner(\n      computedColumnCount,\n      computedColumnWidth,\n      columnGutter,\n      rowGutter ?? columnGutter\n    );\n  };\n  const positionerRef = React.useRef<Positioner>();\n  if (positionerRef.current === undefined)\n    positionerRef.current = initPositioner();\n\n  const prevDeps = React.useRef(deps);\n  const opts = [width, columnWidth, columnGutter, rowGutter, columnCount];\n  const prevOpts = React.useRef(opts);\n  const optsChanged = !opts.every((item, i) => prevOpts.current[i] === item);\n\n  if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n    if (deps.length !== prevDeps.current.length) {\n      throw new Error(\n        \"usePositioner(): The length of your dependencies array changed.\"\n      );\n    }\n  }\n\n  // Create a new positioner when the dependencies or sizes change\n  // Thanks to https://github.com/khmm12 for pointing this out\n  // https://github.com/jaredLunde/masonic/pull/41\n  if (optsChanged || !deps.every((item, i) => prevDeps.current[i] === item)) {\n    const prevPositioner = positionerRef.current;\n    const positioner = initPositioner();\n    prevDeps.current = deps;\n    prevOpts.current = opts;\n\n    if (optsChanged) {\n      const cacheSize = prevPositioner.size();\n      for (let index = 0; index < cacheSize; index++) {\n        const pos = prevPositioner.get(index);\n        positioner.set(index, pos !== void 0 ? pos.height : 0);\n      }\n    }\n\n    positionerRef.current = positioner;\n  }\n\n  return positionerRef.current;\n}\n\nexport interface UsePositionerOptions {\n  /**\n   * The width of the container you're rendering the grid within, i.e. the container\n   * element's `element.offsetWidth`\n   */\n  width: number;\n  /**\n   * The minimum column width. The `usePositioner()` hook will automatically size the\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\n   * It will never render anything smaller than this width unless its container itself is\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\n   *\n   * @default 200\n   */\n  columnWidth?: number;\n  /**\n   * This sets the horizontal space between grid columns in pixels. If `rowGutter` is not set, this\n   * also sets the vertical space between cells within a column in pixels.\n   *\n   * @default 0\n   */\n  columnGutter?: number;\n  /**\n   * This sets the vertical space between cells within a column in pixels. If not set, the value of\n   * `columnGutter` is used instead.\n   */\n  rowGutter?: number;\n  /**\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\n   * (e.g. creating a `List` component).\n   */\n  columnCount?: number;\n}\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount - The number of columns in the grid\n * @param columnWidth - The width of each column in the grid\n * @param columnGutter - The amount of horizontal space between columns in pixels.\n * @param rowGutter - The amount of vertical space between cells within a column in pixels (falls back\n * to `columnGutter`).\n */\nexport const createPositioner = (\n  columnCount: number,\n  columnWidth: number,\n  columnGutter = 0,\n  rowGutter = columnGutter\n): Positioner => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree();\n  // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n  const columnHeights: number[] = new Array(columnCount);\n  // Used for O(1) item access\n  const items: PositionerItem[] = [];\n  // Tracks the item indexes within an individual column\n  const columnItems: number[][] = new Array(columnCount);\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0;\n    columnItems[i] = [];\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0;\n\n      // finds the shortest column and uses it\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i;\n      }\n\n      const top = columnHeights[column] || 0;\n      columnHeights[column] = top + height + rowGutter;\n      columnItems[column].push(index);\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column,\n      };\n      intervalTree.insert(top, top + height, index);\n    },\n    get: (index) => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: (updates) => {\n      const columns: number[] = new Array(columnCount);\n      let i = 0,\n        j = 0;\n\n      // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i];\n        const item = items[index];\n        item.height = updates[++i];\n        intervalTree.remove(index);\n        intervalTree.insert(item.top, item.top + item.height, index);\n        columns[item.column] =\n          columns[item.column] === void 0\n            ? index\n            : Math.min(index, columns[item.column]);\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue;\n        const itemsInColumn = columnItems[i];\n        // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n        const startIndex = binarySearch(itemsInColumn, columns[i]);\n        const index = columnItems[i][startIndex];\n        const startItem = items[index];\n        columnHeights[i] = startItem.top + startItem.height + rowGutter;\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j];\n          const item = items[index];\n          item.top = columnHeights[i];\n          columnHeights[i] = item.top + item.height + rowGutter;\n          intervalTree.remove(index);\n          intervalTree.insert(item.top, item.top + item.height, index);\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) =>\n      intervalTree.search(lo, hi, (index, top) =>\n        renderCallback(index, items[index].left, top)\n      ),\n    estimateHeight: (itemCount, defaultItemHeight): number => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights));\n\n      return itemCount === intervalTree.size\n        ? tallestColumn\n        : tallestColumn +\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\n              defaultItemHeight;\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights);\n      return columnHeights[0] || 0;\n    },\n    size(): number {\n      return intervalTree.size;\n    },\n    all(): PositionerItem[] {\n      return items;\n    },\n  };\n};\n\nexport interface Positioner {\n  /**\n   * The number of columns in the grid\n   */\n  columnCount: number;\n  /**\n   * The width of each column in the grid\n   */\n  columnWidth: number;\n  /**\n   * Sets the position for the cell at `index` based upon the cell's height\n   */\n  set: (index: number, height: number) => void;\n  /**\n   * Gets the `PositionerItem` for the cell at `index`\n   */\n  get: (index: number) => PositionerItem | undefined;\n  /**\n   * Updates cells based on their indexes and heights\n   * positioner.update([index, height, index, height, index, height...])\n   */\n  update: (updates: number[]) => void;\n  /**\n   * Searches the interval tree for grid cells with a `top` value in\n   * betwen `lo` and `hi` and invokes the callback for each item that\n   * is discovered\n   */\n  range: (\n    lo: number,\n    hi: number,\n    renderCallback: (index: number, left: number, top: number) => void\n  ) => void;\n  /**\n   * Returns the number of grid cells in the cache\n   */\n\n  size: () => number;\n  /**\n   * Estimates the total height of the grid\n   */\n\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number;\n  /**\n   * Returns the height of the shortest column in the grid\n   */\n\n  shortestColumn: () => number;\n  /**\n   * Returns all `PositionerItem` items\n   */\n  all: () => PositionerItem[];\n}\n\nexport interface PositionerItem {\n  /**\n   * This is how far from the top edge of the grid container in pixels the\n   * item is placed\n   */\n  top: number;\n  /**\n   * This is how far from the left edge of the grid container in pixels the\n   * item is placed\n   */\n  left: number;\n  /**\n   * This is the height of the grid cell\n   */\n  height: number;\n  /**\n   * This is the column number containing the grid cell\n   */\n  column: number;\n}\n\n/* istanbul ignore next */\nconst binarySearch = (a: number[], y: number): number => {\n  let l = 0;\n  let h = a.length - 1;\n\n  while (l <= h) {\n    const m = (l + h) >>> 1;\n    const x = a[m];\n    if (x === y) return m;\n    else if (x <= y) l = m + 1;\n    else h = m - 1;\n  }\n\n  return -1;\n};\n\nconst getColumns = (\n  width = 0,\n  minimumWidth = 0,\n  gutter = 8,\n  columnCount?: number\n): [number, number] => {\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1;\n  const columnWidth = Math.floor(\n    (width - gutter * (columnCount - 1)) / columnCount\n  );\n  return [columnWidth, columnCount];\n};\n\nconst emptyArr: [] = [];\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n","import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n","import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n","import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n","var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\" + (toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n","import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n","import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n","import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n","var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n","import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n","var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a, _b;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n","var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n","import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n","import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n","import { ResizeObserver as Polyfill } from \"@juggle/resize-observer\";\nimport rafSchd from \"raf-schd\";\nimport * as React from \"react\";\nimport trieMemoize from \"trie-memoize\";\nimport { elementsCache } from \"./elements-cache\";\nimport { useForceUpdate } from \"./use-force-update\";\nimport type { Positioner } from \"./use-positioner\";\n\nconst ResizeObserver =\n  typeof window !== \"undefined\" && \"ResizeObserver\" in window\n    ? window.ResizeObserver\n    : Polyfill;\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner - The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport function useResizeObserver(positioner: Positioner) {\n  const forceUpdate = useForceUpdate();\n  const resizeObserver = createResizeObserver(positioner, forceUpdate);\n  // Cleans up the resize observers when they change or the\n  // component unmounts\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver]);\n  return resizeObserver;\n}\n\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner - A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater - A callback that fires whenever one or many cell heights change.\n */\nexport const createResizeObserver = trieMemoize(\n  [WeakMap],\n  // TODO: figure out a way to test this\n  /* istanbul ignore next */\n  (positioner: Positioner, updater: (updates: number[]) => void) => {\n    const handleEntries = rafSchd(((entries) => {\n      const updates: number[] = [];\n      let i = 0;\n\n      for (; i < entries.length; i++) {\n        const entry = entries[i];\n        const height = (entry.target as HTMLElement).offsetHeight;\n\n        if (height > 0) {\n          const index = elementsCache.get(entry.target);\n\n          if (index !== void 0) {\n            const position = positioner.get(index);\n\n            if (position !== void 0 && height !== position.height)\n              updates.push(index, height);\n          }\n        }\n      }\n\n      if (updates.length > 0) {\n        // Updates the size/positions of the cell with the resize\n        // observer updates\n        positioner.update(updates);\n        updater(updates);\n      }\n    }) as ResizeObserverCallback);\n\n    const ro = new ResizeObserver(handleEntries);\n    // Overrides the original disconnect to include cancelling handling the entries.\n    // Ideally this would be its own method but that would result in a breaking\n    // change.\n    const disconnect = ro.disconnect.bind(ro);\n    ro.disconnect = () => {\n      disconnect();\n      handleEntries.cancel();\n    };\n\n    return ro;\n  }\n);\n","import useEvent from \"@react-hook/event\";\nimport useLatest from \"@react-hook/latest\";\nimport { useThrottleCallback } from \"@react-hook/throttle\";\nimport * as React from \"react\";\nimport type { Positioner, PositionerItem } from \"./use-positioner\";\n\n/**\n * A hook that creates a callback for scrolling to a specific index in\n * the \"items\" array.\n *\n * @param positioner - A positioner created by the `usePositioner()` hook\n * @param options - Configuration options\n */\nexport function useScrollToIndex(\n  positioner: Positioner,\n  options: UseScrollToIndexOptions\n) {\n  const {\n    align = \"top\",\n    element = typeof window !== \"undefined\" && window,\n    offset = 0,\n    height = typeof window !== \"undefined\" ? window.innerHeight : 0,\n  } = options;\n  const latestOptions = useLatest({\n    positioner,\n    element,\n    align,\n    offset,\n    height,\n  } as const);\n  const getTarget = React.useRef(() => {\n    const latestElement = latestOptions.current.element;\n    return latestElement && \"current\" in latestElement\n      ? latestElement.current\n      : latestElement;\n  }).current;\n  const [state, dispatch] = React.useReducer(\n    (\n      state: {\n        position: PositionerItem | undefined;\n        index: number | undefined;\n        prevTop: number | undefined;\n      },\n      action:\n        | { type: \"scrollToIndex\"; value: number | undefined }\n        | { type: \"setPosition\"; value: PositionerItem | undefined }\n        | { type: \"setPrevTop\"; value: number | undefined }\n        | { type: \"reset\" }\n    ) => {\n      const nextState = {\n        position: state.position,\n        index: state.index,\n        prevTop: state.prevTop,\n      };\n\n      /* istanbul ignore next */\n      if (action.type === \"scrollToIndex\") {\n        return {\n          position: latestOptions.current.positioner.get(action.value ?? -1),\n          index: action.value,\n          prevTop: void 0,\n        };\n      } else if (action.type === \"setPosition\") {\n        nextState.position = action.value;\n      } else if (action.type === \"setPrevTop\") {\n        nextState.prevTop = action.value;\n      } else if (action.type === \"reset\") {\n        return defaultState;\n      }\n\n      return nextState;\n    },\n    defaultState\n  );\n  const throttledDispatch = useThrottleCallback(dispatch, 15);\n\n  // If we find the position along the way we can immediately take off\n  // to the correct spot.\n  useEvent(getTarget() as Window, \"scroll\", () => {\n    if (!state.position && state.index) {\n      const position = latestOptions.current.positioner.get(state.index);\n\n      if (position) {\n        dispatch({ type: \"setPosition\", value: position });\n      }\n    }\n  });\n\n  // If the top changes out from under us in the case of dynamic cells, we\n  // want to keep following it.\n  const currentTop =\n    state.index !== void 0 &&\n    latestOptions.current.positioner.get(state.index)?.top;\n\n  React.useEffect(() => {\n    const target = getTarget();\n    if (!target) return;\n    const { height, align, offset, positioner } = latestOptions.current;\n\n    if (state.position) {\n      let scrollTop = state.position.top;\n\n      if (align === \"bottom\") {\n        scrollTop = scrollTop - height + state.position.height;\n      } else if (align === \"center\") {\n        scrollTop -= (height - state.position.height) / 2;\n      }\n\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)));\n      // Resets state after 400ms, an arbitrary time I determined to be\n      // still visually pleasing if there is a slow network reply in dynamic\n      // cells\n      let didUnsubscribe = false;\n      const timeout = setTimeout(\n        () => !didUnsubscribe && dispatch({ type: \"reset\" }),\n        400\n      );\n      return () => {\n        didUnsubscribe = true;\n        clearTimeout(timeout);\n      };\n    } else if (state.index !== void 0) {\n      // Estimates the top based upon the average height of current cells\n      let estimatedTop =\n        (positioner.shortestColumn() / positioner.size()) * state.index;\n      if (state.prevTop)\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height);\n      target.scrollTo(0, estimatedTop);\n      throttledDispatch({ type: \"setPrevTop\", value: estimatedTop });\n    }\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch]);\n\n  return React.useRef((index: number) => {\n    dispatch({ type: \"scrollToIndex\", value: index });\n  }).current;\n}\n\nconst defaultState = {\n  index: void 0,\n  position: void 0,\n  prevTop: void 0,\n} as const;\n\nexport type UseScrollToIndexOptions = {\n  /**\n   * The window element or a React ref for the window element. That is,\n   * this is the grid container.\n   *\n   * @default window\n   */\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null;\n  /**\n   * Sets the vertical alignment of the cell within the grid container.\n   *\n   * @default \"top\"\n   */\n  align?: \"center\" | \"top\" | \"bottom\";\n  /**\n   * The height of the grid.\n   *\n   * @default window.innerHeight\n   */\n  height?: number;\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the window.\n   *\n   * @default 0\n   */\n  offset?: number;\n};\n","import { useWindowSize } from \"@react-hook/window-size\";\nimport * as React from \"react\";\nimport { MasonryScroller } from \"./masonry-scroller\";\nimport type { MasonryScrollerProps } from \"./masonry-scroller\";\nimport { useContainerPosition } from \"./use-container-position\";\nimport { usePositioner } from \"./use-positioner\";\nimport type { UsePositionerOptions } from \"./use-positioner\";\nimport { useResizeObserver } from \"./use-resize-observer\";\nimport { useScrollToIndex } from \"./use-scroll-to-index\";\nimport type { UseScrollToIndexOptions } from \"./use-scroll-to-index\";\n\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n *\n * @param props\n */\nexport function Masonry<Item>(props: MasonryProps<Item>) {\n  const containerRef = React.useRef<null | HTMLElement>(null);\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight,\n  });\n  const containerPos = useContainerPosition(containerRef, windowSize);\n  const nextProps = Object.assign(\n    {\n      offset: containerPos.offset,\n      width: containerPos.width || windowSize[0],\n      height: windowSize[1],\n      containerRef,\n    },\n    props\n  ) as any;\n  nextProps.positioner = usePositioner(nextProps);\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner);\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\n    height: nextProps.height,\n    offset: containerPos.offset,\n    align:\n      typeof props.scrollToIndex === \"object\"\n        ? props.scrollToIndex.align\n        : void 0,\n  });\n  const index =\n    props.scrollToIndex &&\n    (typeof props.scrollToIndex === \"number\"\n      ? props.scrollToIndex\n      : props.scrollToIndex.index);\n\n  React.useEffect(() => {\n    if (index !== void 0) scrollToIndex(index);\n  }, [index, scrollToIndex]);\n\n  return React.createElement(MasonryScroller, nextProps);\n}\n\nexport interface MasonryProps<Item>\n  extends Omit<\n      MasonryScrollerProps<Item>,\n      \"offset\" | \"width\" | \"height\" | \"containerRef\" | \"positioner\"\n    >,\n    Pick<\n      UsePositionerOptions,\n      \"columnWidth\" | \"columnGutter\" | \"rowGutter\" | \"columnCount\"\n    > {\n  /**\n   * Scrolls to a given index within the grid. The grid will re-scroll\n   * any time the index changes.\n   */\n  scrollToIndex?:\n    | number\n    | {\n        index: number;\n        align: UseScrollToIndexOptions[\"align\"];\n      };\n  /**\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrWidth?: number;\n  /**\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrHeight?: number;\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   *\n   * @default 12\n   */\n  scrollFps?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  Masonry.displayName = \"Masonry\";\n}\n","import {useDebounce} from '@react-hook/debounce'\nimport useEvent from '@react-hook/event'\n\nconst emptyObj = {}\n\nexport interface DebouncedWindowSizeOptions {\n  initialWidth?: number\n  initialHeight?: number\n  wait?: number\n  leading?: boolean\n}\n\nconst win = typeof window === 'undefined' ? null : window\nconst getSize = () =>\n  [\n    document.documentElement.clientWidth,\n    document.documentElement.clientHeight,\n  ] as const\n\nexport const useWindowSize = (\n  options: DebouncedWindowSizeOptions = emptyObj\n): readonly [number, number] => {\n  const {wait, leading, initialWidth = 0, initialHeight = 0} = options\n  const [size, setDebouncedSize] = useDebounce<readonly [number, number]>(\n    /* istanbul ignore next */\n    typeof document === 'undefined' ? [initialWidth, initialHeight] : getSize,\n    wait,\n    leading\n  )\n  const setSize = (): void => setDebouncedSize(getSize)\n\n  useEvent(win, 'resize', setSize)\n  useEvent(win, 'orientationchange', setSize)\n\n  return size\n}\n\nexport const useWindowHeight = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialWidth'>\n): number => useWindowSize(options)[1]\n\nexport const useWindowWidth = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialHeight'>\n): number => useWindowSize(options)[0]\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nexport const useDebounceCallback = <CallbackArgs extends any[]>(\n  callback: (...args: CallbackArgs) => void,\n  wait = 100,\n  leading = false\n): ((...args: CallbackArgs) => void) => {\n  const storedCallback = useLatest(callback)\n  const timeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const deps = [wait, leading, storedCallback]\n  // Cleans up pending timeouts when the deps change\n  React.useEffect(\n    () => () => {\n      timeout.current && clearTimeout(timeout.current)\n      timeout.current = void 0\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const {current} = timeout\n    // Calls on leading edge\n    if (current === void 0 && leading) {\n      timeout.current = setTimeout(() => {\n        timeout.current = void 0\n      }, wait)\n      // eslint-disable-next-line prefer-spread\n      return storedCallback.current.apply(null, args as any)\n    }\n    // Clear the timeout every call and start waiting again\n    current && clearTimeout(current)\n    // Waits for `wait` before invoking the callback\n    timeout.current = setTimeout(() => {\n      timeout.current = void 0\n      storedCallback.current.apply(null, args as any)\n    }, wait)\n  }, deps)\n}\n\nexport const useDebounce = <State extends any>(\n  initialState: State | (() => State),\n  wait?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] => {\n  const state = React.useState(initialState)\n  return [state[0], useDebounceCallback(state[1], wait, leading)]\n}\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  React.useEffect(() => {\n    storedValue.current = current\n  })\n  return storedValue\n}\n\nexport default useLatest\n","import React from 'react'\n\nconst usePassiveLayoutEffect =\n  React[\n    typeof document !== 'undefined' && document.createElement !== void 0\n      ? 'useLayoutEffect'\n      : 'useEffect'\n  ]\n\nexport default usePassiveLayoutEffect\n","const memoOne = <Args extends any[], T extends any>(\n  fn: (...args: Args) => T,\n  areEqual?: AreEqual<Args>\n): OutputFunction<Args, T> => {\n  const equal = areEqual || defaultAreEqual\n  let args: Args, value: any\n\n  return function (): T {\n    return !!args && equal(arguments as any, args)\n      ? value\n      : (value = fn.apply(null, (args = arguments as any)))\n  } as OutputFunction<Args, T>\n}\n\nexport default memoOne\n\nconst defaultAreEqual = (\n  current: IArguments,\n  prev: IArguments | any[]\n): boolean =>\n  current[0] === prev[0] &&\n  current[1] === prev[1] &&\n  current[2] === prev[2] &&\n  current[3] === prev[3]\n\nexport type AreEqual<Args> = (currentArgs: Args, prevArgs: Args) => boolean\nexport type InputFunction = (...args: any[]) => any\nexport type OutputFunction<Args extends any[], T extends any> = (\n  ...args: Args\n) => T\n","class OneKeyMap<K extends any = any, V extends any = any> {\n  set: (k: K, v: V) => void\n  get: (k: K) => V | undefined\n\n  constructor() {\n    let key: K | undefined, val: V | undefined\n    this.get = (k: K): V | undefined => (k === key ? val : void 0)\n    this.set = (k: K, v: V): void => {\n      key = k\n      val = v\n    }\n  }\n}\n\nexport default OneKeyMap\n","export interface MapLike {\n  new (...args: any[]): any\n}\n\nexport type CacheConstructor =\n  | MapConstructor\n  | WeakMapConstructor\n  | MapLike\n  | Record<any, any>\n\ninterface Cache<K = any, V = any> {\n  set: (k: K, v: V) => V\n  get: (k: K) => V\n}\n\nconst createCache = (obj: CacheConstructor): Cache => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache: Record<string, any> = {}\n\n    return {\n      set(k, v): void {\n        cache[k] = v\n      },\n      get(k): any {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (\n  constructors: CacheConstructor[]\n): {s: Cache['set']; g: Cache['get']} => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base: any\n  let map: any\n  let i: number\n  let node: typeof baseCache\n  const one = depth === 1\n  // quicker access for one and two-argument functions\n  const g1 = (args: IArguments): any =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n  const s1 = (args: IArguments, value: any): any => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n\n    return value\n  }\n\n  const g2 = (args: IArguments): any => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args: IArguments, value: any): any => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3 ? {g: g1, s: s1} : {g: g2, s: s2}\n}\n\nconst memoize = <T extends any[], U extends any>(\n  mapConstructors: CacheConstructor[],\n  fn: (...args: T) => U\n): ((...args: T) => U) => {\n  let item: U\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments as any))\n      : item\n  }\n}\n\nexport default memoize\n","export const elementsCache: WeakMap<Element, number> = new WeakMap();\n","export type Raf = (callback: (timestamp: number) => void) => number\nexport type Caf = (handle: number) => void\n\nlet u = 'undefined',\n  win = typeof window !== u ? window : ({} as any),\n  p = typeof performance !== u ? performance : Date,\n  now = () => p.now(),\n  af = 'AnimationFrame' as const,\n  Caf = 'cancel' + af,\n  Raf = 'request' + af,\n  raf: Raf = win[Raf] && win[Raf].bind(win),\n  caf: Caf = win[Caf] && win[Caf].bind(win)\n\nif (!raf || !caf) {\n  let lastTime = 0\n  raf = (callback: FrameRequestCallback) => {\n    let curr = now(),\n      next = Math.max(lastTime + 1000 / 60, curr)\n    return setTimeout(() => {\n      callback((lastTime = next))\n    }, next - curr) as any\n  }\n  caf = (h) => clearTimeout(h)\n}\n\nexport {raf, caf, now}\n","var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n","import {useThrottle} from '@react-hook/throttle'\nimport useEvent from '@react-hook/event'\n\nconst win = typeof window === 'undefined' ? null : window\nconst getScrollY = (): number =>\n  (win as Window).scrollY !== void 0\n    ? (win as Window).scrollY\n    : (win as Window).pageYOffset === void 0\n    ? 0\n    : (win as Window).pageYOffset\n\nexport const useWindowScroll = (fps = 30): number => {\n  const state = useThrottle(\n    typeof window === 'undefined' ? 0 : getScrollY,\n    fps,\n    true\n  )\n  useEvent(win, 'scroll', (): void => state[1](getScrollY()))\n  return state[0]\n}\n\nexport default useWindowScroll\n","var resizeObservers = [];\nexport { resizeObservers };\n","export var freeze = function (obj) { return Object.freeze(obj); };\n","export var global = typeof window !== 'undefined' ? window : {};\n","import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n","import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n","var rafSchd = function rafSchd(fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function wrapperFn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  wrapperFn.cancel = function () {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n  };\n\n  return wrapperFn;\n};\n\nexport default rafSchd;\n","import useLatest from \"@react-hook/latest\";\nimport * as React from \"react\";\n\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems - This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\n  loadMoreItems: T,\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\n): LoadMoreItemsCallback<Item> {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9,\n  } = options;\n  const storedLoadMoreItems = useLatest(loadMoreItems);\n  const storedIsItemLoaded = useLatest(isItemLoaded);\n\n  return React.useCallback(\n    (startIndex, stopIndex, items) => {\n      const unloadedRanges = scanForUnloadedRanges(\n        storedIsItemLoaded.current,\n        minimumBatchSize,\n        items,\n        totalItems,\n        Math.max(0, startIndex - threshold),\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\n      );\n      // The user is responsible for memoizing their loadMoreItems() function\n      // because we don't want to make assumptions about how they want to deal\n      // with `items`\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\n        storedLoadMoreItems.current(\n          unloadedRanges[i],\n          unloadedRanges[++i],\n          items\n        );\n    },\n    [\n      totalItems,\n      minimumBatchSize,\n      threshold,\n      storedLoadMoreItems,\n      storedIsItemLoaded,\n    ]\n  );\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n *\n * @param isItemLoaded\n * @param minimumBatchSize\n * @param items\n * @param totalItems\n * @param startIndex\n * @param stopIndex\n */\nfunction scanForUnloadedRanges<Item>(\n  isItemLoaded: UseInfiniteLoaderOptions<Item>[\"isItemLoaded\"] = defaultIsItemLoaded,\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>[\"minimumBatchSize\"] = 16,\n  items: any[],\n  totalItems: UseInfiniteLoaderOptions<Item>[\"totalItems\"] = 9e9,\n  startIndex: number,\n  stopIndex: number\n): number[] {\n  const unloadedRanges: number[] = [];\n  let rangeStartIndex: number | undefined,\n    rangeStopIndex: number | undefined,\n    index = startIndex;\n\n  /* istanbul ignore next */\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === void 0) rangeStartIndex = index;\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = void 0;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      totalItems - 1\n    );\n\n    /* istanbul ignore next */\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  /* istanbul ignore next */\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0];\n    const firstUnloadedStop = unloadedRanges[1];\n\n    while (\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\n      firstUnloadedStart > 0\n    ) {\n      const index = firstUnloadedStart - 1;\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\n  items[index] !== void 0;\n\nexport interface UseInfiniteLoaderOptions<Item> {\n  /**\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\n   * if the item has already been loaded and `false` if not.\n   *\n   * @default (index: number, items: any[]) => boolean\n   */\n  isItemLoaded?: (index: number, items: Item[]) => boolean;\n  /**\n   * The minimum number of new items to be loaded at a time.  This property can be used to\n   * batch requests and reduce HTTP requests.\n   *\n   * @default 16\n   */\n  minimumBatchSize?: number;\n  /**\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\n   * loading when a user scrolls within X cells of the end of your `items` array.\n   *\n   * @default 16\n   */\n  threshold?: number;\n  /**\n   * The total number of items you'll need to eventually load (if known). This can\n   * be arbitrarily high if not known.\n   *\n   * @default 9e9\n   */\n  totalItems?: number;\n}\n\nexport type LoadMoreItemsCallback<Item> = (\n  startIndex: number,\n  stopIndex: number,\n  items: Item[]\n) => any;\n\nconst emptyObj = {};\n","import * as React from \"react\";\nimport { Masonry } from \"./masonry\";\nimport type { MasonryProps } from \"./masonry\";\n\n/**\n * This is just a single-column `<Masonry>` component without column-specific props.\n *\n * @param props\n */\nexport function List<Item>(props: ListProps<Item>) {\n  return (\n    <Masonry<Item>\n      role=\"list\"\n      rowGutter={props.rowGutter}\n      columnCount={1}\n      columnWidth={1}\n      {...props}\n    />\n  );\n}\n\nexport interface ListProps<Item>\n  extends Omit<\n    MasonryProps<Item>,\n    \"columGutter\" | \"columnCount\" | \"columnWidth\"\n  > {\n  /**\n   * The amount of vertical space in pixels to add between the list cells.\n   *\n   * @default 0\n   */\n  rowGutter?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  List.displayName = \"List\";\n}\n"],"names":["updateMax","node","max","high","L","NULL_NODE","R","Math","updateMaxUp","x","P","rotateLeft","tree","y","root","rotateRight","replaceNode","createIntervalTree","size","indexMap","insert","low","index","treeNode","prevNode","list","next","addInterval","z","C","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","callback","stack","length","pop","push","curr","useEvent","target","type","listener","cleanup","storedListener","React","useRef","storedCleanup","useLayoutEffect","current","didUnsubscribe","args","apply","this","targetEl","addEventListener","removeEventListener","useForceUpdate","setState","useState","emptyObj","useMasonry","stopIndex","positioner","resizeObserver","items","as","ContainerComponent","id","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","scrollTop","isScrolling","height","RenderComponent","render","onRender","startIndex","forceUpdate","setItemRef","getRefSetter","itemCount","columnWidth","columnCount","range","estimateHeight","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","undefined","storedOnRender","useLatest","rangeEnd","needsFreshBatch","left","top","data","key","phaseTwoStyle","width","writingMode","position","__reactCreateElement__","ref","_extends","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","useEffect","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","useThrottleCallback","fps","leading","prev","clearTrailing","storedCallback","ms","trailingTimeout","clearTimeout","deps","useCallback","arguments","rightNow","now","call","setTimeout","useScroller","offset","useScrollPosition","setIsScrolling","didMount","fn","start","handle","to","v","raf","loop","caf","clearRequestTimeout","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","emptyArr","containerPosition","setContainerPosition","el","offsetTop","offsetParent","offsetWidth","usePositioner","columnGutter","rowGutter","initPositioner","getColumns","computedColumnWidth","computedColumnCount","createPositioner","positionerRef","prevDeps","opts","prevOpts","optsChanged","every","item","prevPositioner","cacheSize","pos","get","set","ro","activeTargets","skippedTargets","ResizeObserverSize","inlineSize","blockSize","freeze","DOMRectReadOnly","bottom","right","_a","rectangle","ResizeObserverEntry","boxes","calculateBoxSizes","contentRect","borderBoxSize","contentBoxSize","devicePixelContentBoxSize","cb","callbacks","splice","forEach","Scheduler","_this","stopped","schedule","timeout","scheduled","until","time","elementsHaveResized","event","depth","gatherActiveObservationsAtDepth","hasActiveObservations","broadcastActiveObservations","resizeObservers","some","ErrorEvent","message","msg","document","createEvent","initEvent","window","dispatchEvent","process","watching","run","trigger","toggle_1","el_1","createTextNode","MutationObserver","observe","characterData","textContent","requestAnimationFrame","queueMicroTask","stop","observer","body","observerConfig","global","events","name","disconnect","ResizeObservation","observedBox","ResizeObserverBoxOptions","CONTENT_BOX","lastReportedSize","calculateBoxSize","isSVG","tagName","isReplacedElement","getComputedStyle","display","ResizeObserverDetail","observationTargets","ResizeObserverController","detail","observerMap","options","firstObservation","getObservationIndex","box","updateCount","scheduler","lastObservation","indexOf","slice","ot","unobserve","ResizeObserver","TypeError","connect","isElement","useResizeObserver","createResizeObserver","useScrollToIndex","align","element","innerHeight","latestOptions","getTarget","latestElement","useReducer","state","action","nextState","prevTop","value","defaultState","dispatch","throttledDispatch","currentTop","_latestOptions$curren","scrollTo","estimatedTop","Masonry","windowSize","wait","initialWidth","initialHeight","initialState","useDebounceCallback","useDebounce","getSize","setDebouncedSize","setSize","win","useWindowSize","ssrWidth","ssrHeight","containerPos","nextProps","scrollToIndex","storedValue","createElement","documentElement","clientWidth","clientHeight","areEqual","equal","defaultAreEqual","val","k","createCache","obj","e","cache","mapConstructors","constructors","base","map","baseCache","one","g","s","elementsCache","WeakMap","trieMemoize","OneKeyMap","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","pargs","userStyle","zIndex","visibility","offsetHeight","u","p","performance","Date","af","Caf","Raf","bind","lastTime","h","perf","getScrollY","scrollY","pageYOffset","useThrottle","intervalTree","columnHeights","Array","columnItems","column","update","updates","columns","j","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","all","a","l","m","minimumWidth","gutter","floor","Object","prototype","toJSON","fromRect","SVGElement","isHidden","getBBox","_b","getClientRects","Element","scope","ownerDocument","defaultView","scrollRegexp","verticalRegexp","IE","test","navigator","userAgent","parseDimension","pixel","parseFloat","switchSizes","zeroBoxes","forceRecalculation","has","cs","svg","ownerSVGElement","removePadding","boxSizing","canScrollVertically","overflowY","canScrollHorizontally","overflowX","paddingTop","paddingRight","paddingBottom","paddingLeft","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","horizontalPadding","verticalPadding","horizontalBorderArea","borderLeftWidth","verticalBorderArea","horizontalScrollbarThickness","verticalScrollbarThickness","widthReduction","heightReduction","contentWidth","contentHeight","borderBoxWidth","borderBoxHeight","round","devicePixelRatio","DEVICE_PIXEL_CONTENT_BOX","BORDER_BOX","calculateDepthForNode","Infinity","parent","parentNode","shallowestDepth","entries","entry","targetDepth","_i","callbacks_1","isActive","attributes","childList","subtree","n","toString","Polyfill","updater","handleEntries","frameId","lastArgs","wrapperFn","_len","_key","cancel","cancelAnimationFrame","rafSchd","defaultIsItemLoaded","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges"],"mappings":"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"}